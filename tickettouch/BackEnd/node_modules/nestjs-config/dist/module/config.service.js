"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ConfigService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigService = void 0;
const common_1 = require("@nestjs/common");
const assert = require("assert");
const get = require("lodash.get");
const set = require("lodash.set");
const dotenv_1 = require("dotenv");
const path = require("path");
const glob_1 = require("glob");
const proxy_1 = require("../decorators/proxy");
let ConfigService = ConfigService_1 = class ConfigService {
    /**
     * @param {Config} config
     */
    constructor(config = {}) {
        this.helpers = {};
        this.bindCustomHelpers(config);
        ConfigService_1.config = config;
    }
    /**
     * Load configuration from file system
     * @param glob string
     * @param {DotenvOptions} options
     * @returns {Promise<any>}
     */
    static load(glob, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const configs = yield this.loadConfigAsync(glob, options);
            return new ConfigService_1(configs);
        });
    }
    /**
     * Load config synchronously
     * @param {string} glob
     * @param {DotenvOptions | false} options
     */
    static loadSync(glob, options) {
        const configs = this.loadConfigSync(glob, options);
        return new ConfigService_1(configs);
    }
    /**
     * Get the param or use default
     *
     * @param {String} key
     * @param {any} value default
     * @returns {any|undefined}
     */
    static get(param, value = undefined) {
        const configValue = get(ConfigService_1.config, param);
        if (configValue === undefined) {
            return value;
        }
        return configValue;
    }
    /**
     * Get the param or use default
     *
     * @param param
     * @param {any} value default
     * @returns {any}
     */
    get(param, value = undefined) {
        return ConfigService_1.get(param, value);
    }
    /**
     * Set config value at runtime
     * @param {string} param
     * @param value
     * @returns {Config}
     */
    set(param, value = null) {
        return set(ConfigService_1.config, param, value);
    }
    /**
     * Check the param exists
     *
     * @param param
     * @returns {boolean}
     */
    has(param) {
        return get(ConfigService_1.config, param) !== undefined;
    }
    /**
     * Merge configuration
     * @param glob
     * @param options
     */
    merge(glob, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield ConfigService_1.loadConfigAsync(glob, options);
            Object.keys(config).forEach((configName) => {
                ConfigService_1.config[configName] = config[configName];
            });
        });
    }
    /**
     * Merge configuration synchronously
     * @param {string} glob
     * @param {DotenvOptions} options
     * @returns {ConfigService}
     */
    mergeSync(glob, options) {
        const config = ConfigService_1.loadConfigSync(glob, options);
        Object.keys(config).forEach((configName) => {
            ConfigService_1.config[configName] = config[configName];
        });
        return this;
    }
    /**
     * @param {string} name
     * @param {CustomHelper} fn
     * @returns {ConfigService}
     */
    registerHelper(name, fn) {
        this.helpers[name] = fn.bind(this);
        return this;
    }
    /**
     * @param {string} dir
     * @returns {string}
     */
    static root(dir = '') {
        const rootPath = this.rootPath || this.srcPath || path.resolve(process.cwd());
        return path.resolve(rootPath, dir);
    }
    /**
     * @param {string} dir
     * @returns {string}
     *
     * @deprecated use configService.root() instead
     */
    static src(dir = '') {
        console.log(`\x1b[33m%s\x1b[0m`, `WARNING: Method 'src' has been deprecated. Please use 'root'`);
        return this.root(dir);
    }
    /**
     * Resolves and stores sources directory for application.
     * @param {string} startPath
     *  The path for search starting. Can be any path under app sources path.
     */
    static resolveRootPath(startPath) {
        assert.ok(path.isAbsolute(startPath), 'Start path must be an absolute path.');
        if (!this.rootPath) {
            const root = this.root();
            let workingDir = startPath;
            let parent = path.dirname(startPath);
            while (workingDir !== root && parent !== root && parent !== workingDir) {
                workingDir = parent;
                parent = path.dirname(workingDir);
            }
            this.rootPath = workingDir;
            this.srcPath = workingDir;
        }
        return this;
    }
    /**
     * @param startPath
     *
     * @deprecated use configService.resolveRootPath() instead
     */
    static resolveSrcPath(startPath) {
        console.log(`\x1b[33m%s\x1b[0m`, `WARNING: Method 'resolveSrcPath' has been deprecated. Please use 'resolveRootPath'`);
        return this.resolveRootPath(startPath);
    }
    /**
     * @param {string | string[]} glob
     * @param {DotenvOptions | false} options
     * @returns {Promise<Config>}
     */
    static loadConfigAsync(glob, options) {
        glob = this.root(glob);
        return new Promise((resolve, reject) => {
            new glob_1.Glob(glob, {}, (err, matches) => {
                /* istanbul ignore if */
                if (err) {
                    reject(err);
                }
                else {
                    this.loadEnv(options);
                    const configs = this.configGraph(matches, options && options.modifyConfigName);
                    resolve(configs);
                }
            });
        });
    }
    /**
     * Load config synchronously
     * @param {string} glob
     * @param {DotenvOptions | false} options
     * @returns {Config}
     */
    static loadConfigSync(glob, options) {
        glob = this.root(glob);
        const matches = (0, glob_1.sync)(glob);
        this.loadEnv(options);
        return this.configGraph(matches, options && options.modifyConfigName);
    }
    /**
     * Config graph from an array of paths
     * @param configPaths
     * @param modifyConfigName
     * @returns {any}
     */
    static configGraph(configPaths, modifyConfigName) {
        return configPaths.reduce((configs, file) => {
            const module = require(file);
            const config = module.default || module;
            const configName = modifyConfigName
                ? modifyConfigName(this.getConfigName(file))
                : this.getConfigName(file);
            configs[configName] = config;
            return configs;
        }, {});
    }
    /**
     * @param config
     * @returns {string}
     */
    bindCustomHelpers(config) {
        return Object.keys(config).reduce((configObj, configName) => {
            if (typeof configObj[configName] === 'function') {
                const helper = configObj[configName].bind(this);
                configObj[configName] = helper;
                this.helpers[`_${configName}`] = helper;
            }
            if (typeof configObj[configName] === 'object' &&
                configObj[configName] !== null) {
                configObj[configName] = this.bindCustomHelpers(configObj[configName]);
            }
            return configObj;
        }, config);
    }
    /**
     * Get config name from a file path
     * @param {string} file
     * @returns {string}
     */
    static getConfigName(file) {
        const ext = path.extname(file);
        return path.basename(file, ext);
    }
    /**
     * Loads env variables via dotenv.
     * @param {DotenvConfigOptions | false} options
     */
    static loadEnv(options) {
        if (options !== false) {
            (0, dotenv_1.config)(options || ConfigService_1.defaultDotenvConfig());
        }
    }
    /**
     * Default dotenv config point to a .env
     * on the cwd path
     * @returns {{path: string}}
     */
    static defaultDotenvConfig() {
        return {
            path: path.join(process.cwd(), '.env'),
        };
    }
};
ConfigService = ConfigService_1 = __decorate([
    (0, common_1.Injectable)(),
    (0, proxy_1.ProxyProperty)('helpers'),
    __metadata("design:paramtypes", [Object])
], ConfigService);
exports.ConfigService = ConfigService;
